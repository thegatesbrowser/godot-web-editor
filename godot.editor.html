<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
		<meta name="author" content="Godot Engine">
		<meta name="description" content="Use the Godot Engine editor directly in your web browser, without having to install anything.">
		<meta name="mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="application-name" content="Godot">
		<meta name="apple-mobile-web-app-title" content="Godot">
		<meta name="theme-color" content="#252525">
		<meta name="msapplication-navbutton-color" content="#252525">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="msapplication-starturl" content="/latest">
		<meta property="og:site_name" content="Godot Engine Web Editor">
		<meta property="og:url" name="twitter:url" content="https://editor.godotengine.org/releases/latest/">
		<meta property="og:title" name="twitter:title" content="Free and open source 2D and 3D game engine">
		<meta property="og:description" name="twitter:description" content="Use the Godot Engine editor directly in your web browser, without having to install anything.">
		<meta property="og:image" name="twitter:image" content="https://godotengine.org/themes/godotengine/assets/og_image.png">
		<meta property="og:type" content="website">
		<meta name="twitter:card" content="summary">
		<link id="-gd-engine-icon" rel="icon" type="image/png" href="favicon.png">
		<link rel="apple-touch-icon" type="image/png" href="favicon.png">
		<link rel="manifest" href="manifest.json">
		<title>Godot Engine Web Editor (4.5.stable.official)</title>
		<style>
:root {
	--theme-background: #252525;
	--theme-surface: #2f2f2f;
	--theme-surface-dark: #1f1f1f;
	--theme-border: #3a3a3a;
	--theme-border-strong: #4a4a4a;
	--theme-accent: #3d85f2;
	--theme-accent-strong: #63a1f8;
	--theme-accent-soft: rgba(61, 133, 242, 0.12);
	--theme-highlight-glow: rgba(61, 133, 242, 0.35);
	--theme-text: #f0f0f0;
}

*:focus {
	/* More visible outline for better keyboard navigation. */
	outline: 0.125rem solid var(--theme-accent);
	/* Make the outline always appear above other elements. */
	/* Otherwise, one of its sides can be hidden by tabs in the Download and More layouts. */
	position: relative;
}

html,
body {
	height: 100%;
}

body {
	touch-action: none;
	font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
	margin: 0;
	border: 0 none;
	padding: 0;
	text-align: center;
	background-color: var(--theme-background);
	color: var(--theme-text);
	overflow: hidden;
	display: flex;
	flex-direction: column;
	background-image: linear-gradient(180deg, rgba(20,20,20,0.65), rgba(37,37,37,0.65));
}

a {
	color: var(--theme-accent-strong);
	text-decoration-color: rgba(99, 161, 248, 0.35);
	text-decoration-thickness: 0.125rem;
}

a:hover {
	filter: brightness(112.5%);
}

a:active {
	filter: brightness(90%);
}

.welcome-modal {
	display: none;
	position: fixed;
	z-index: 1;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	overflow: auto;
	background-color: hsla(0, 0%, 0%, 0.5);
	text-align: left;
}

.welcome-modal-title {
	text-align: center;
}

.welcome-modal-content {
	background-color: var(--theme-surface);
	box-shadow: 0 0.25rem 0.25rem hsla(0, 0%, 0%, 0.5);
	line-height: 1.5;
	max-width: 38rem;
	margin: 4rem auto 0 auto;
	color: var(--theme-text);
	border-radius: 0.5rem;
	padding: 1rem 1rem 2rem 1rem;
}

#tabs-buttons {
	/* Match the default background color of the editor window for a seamless appearance. */
	background-color: var(--theme-surface-dark);
	border-bottom: 1px solid var(--theme-border);
}

#tab-game {
	/* Use a pure black background to better distinguish the running project */
	/* from the editor window, and to use a more neutral background color (no tint). */
	background-color: black;
	/* Make the background span the entire page height. */
	min-height: 100vh;
}

#canvas, #gameCanvas {
	display: block;
	margin: 0;
	color: white;
}

/* Don't show distracting focus outlines for the main tabs' contents. */
#tab-editor canvas:focus,
#tab-game canvas:focus,
#canvas:focus,
#gameCanvas:focus {
	outline: none;
}

.godot {
	color: var(--theme-text);
	background-color: var(--theme-surface);
	background-image: linear-gradient(to bottom, #2f2f2f, #262626);
	border: 1px solid var(--theme-border);
	box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.4), 0 6px 18px rgba(0, 0, 0, 0.35);
}

.btn {
	appearance: none;
	color: var(--theme-text);
	background-color: var(--theme-surface);
	border: 1px solid var(--theme-border);
	padding: 0.5rem 1rem;
	margin: 0 0.5rem;
	transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
}

.btn:not(:disabled):hover {
	color: var(--theme-accent-strong);
	border-color: var(--theme-accent);
	background-color: var(--theme-surface-dark);
	box-shadow: 0 0 0 1px rgba(61, 133, 242, 0.4), 0 6px 16px rgba(61, 133, 242, 0.25);
}

.btn:active {
	border-color: var(--theme-accent);
	color: var(--theme-accent-strong);
	background-color: rgba(61, 133, 242, 0.1);
}

.btn:disabled {
	color: #8a8a8a;
	border-color: #2c2c2c;
	background-color: #181818;
	box-shadow: none;
}

.btn.tab-btn {
	padding: 0.3rem 1rem;
}

.btn.close-btn {
	padding: 0.3rem 1rem;
	margin-left: -0.75rem;
	font-weight: 700;
}

/* Status display */

#tabs {
	position: relative;
	height: 100%;
	width: 100%;
	flex: 1;
}

#tab-status {
	position: absolute;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	width: 100%;
	height: 100%;
	background: transparent;
}

#status {
	position: absolute;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	width: 100%;
	height: 100%;
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	gap: 1.25rem;
	padding: 2rem;
	box-sizing: border-box;
	pointer-events: none;
	background: linear-gradient(180deg, rgba(37, 37, 37, 0.92) 0%, rgba(27, 27, 27, 0.75) 100%);
}

#status-progress {
	width: min(520px, 85vw);
	border-radius: 12px;
	padding: 1.25rem 1.5rem;
	background: linear-gradient(180deg, rgba(46, 46, 46, 0.95) 0%, rgba(32, 32, 32, 0.92) 100%);
	box-shadow: 0 12px 40px rgba(0, 0, 0, 0.55), 0 0 0 1px rgba(61, 133, 242, 0.15);
	display: flex;
	flex-direction: column;
	gap: 0.75rem;
	visibility: visible;
	pointer-events: auto;
}

#status-progress-label {
	font-size: 1.05rem;
	font-weight: 600;
	letter-spacing: 0.015em;
	color: var(--theme-text);
	text-transform: uppercase;
	opacity: 0.9;
}

#status-progress-bar {
	width: 100%;
	height: 1rem;
	background: linear-gradient(180deg, rgba(22, 22, 22, 0.95), rgba(30, 30, 30, 0.9));
	border: 1px solid rgba(99, 161, 248, 0.35);
	border-radius: 999px;
	box-shadow: inset 0 3px 9px rgba(0,0,0,0.55);
	overflow: hidden;
}

#status-progress-inner {
	height: 100%;
	width: 0;
	transition: width 0.25s ease-out;
	background: linear-gradient(90deg, rgba(61, 133, 242, 0.95) 0%, rgba(99, 161, 248, 1) 50%, rgba(61, 133, 242, 0.95) 100%);
	filter: drop-shadow(0 0 8px rgba(61, 133, 242, 0.4));
}

#status-progress-inner.indeterminate {
	width: 32%;
	min-width: 3.5rem;
	animation: status-progress-indeterminate 1.2s ease-in-out infinite alternate;
	transition: none;
}

@keyframes status-progress-indeterminate {
	0% { transform: translateX(-45%); }
	50% { transform: translateX(0%); }
	100% { transform: translateX(45%); }
}

#status-log {
	width: min(520px, 85vw);
	min-height: 2.5rem;
	max-height: 18vh;
	overflow-y: auto;
	padding: 0.9rem 1.1rem;
	border-radius: 10px;
	background: rgba(34, 34, 34, 0.9);
	box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
	border: 1px solid rgba(61, 133, 242, 0.25);
	color: var(--theme-accent-strong);
	font-family: 'Fira Code', Consolas, monospace;
	font-size: 0.85rem;
	line-height: 1.45;
	text-align: left;
	opacity: 0.88;
	pointer-events: auto;
}

#status-log-entry {
	white-space: pre-wrap;
}
		</style>
		<script>
(function () {
'use strict';
const KEY = 'thegates_user_id';

function getFromCookies(name) {
	const prefix = name + '=';
	const parts = document.cookie ? document.cookie.split('; ') : [];
	for (let i = 0; i < parts.length; i++) {
		if (parts[i].startsWith(prefix)) {
			return parts[i].slice(prefix.length);
		}
	}
	return null;
}

function setCookie(name, value) {
	const expires = 'Fri, 31 Dec 9999 23:59:59 GMT';
	document.cookie = name + '=' + value + '; path=/; expires=' + expires + '; SameSite=Lax';
}

function getFromStorage() {
    try {
        const id = localStorage.getItem(KEY);
        if (id) return id;
    } catch (e) {}
    return getFromCookies(KEY);
}

let currentId = null;

function setId(id) {
	if (!id || typeof id !== 'string') return;
	currentId = id;
	try { localStorage.setItem(KEY, id); } catch (e) {}
	try { setCookie(KEY, id); } catch (e) {}
}

async function fetchServerId() {
	try {
		const resp = await fetch('/api/create_publishing_user_id', { method: 'POST', cache: 'no-store' });
		if (resp.ok) {
			const contentType = resp.headers.get('content-type') || '';
			let raw = '';
			if (contentType.includes('application/json')) {
				try {
					const json = await resp.json();
					raw = (json && (json.user_id || json.id || '')) + '';
				} catch (e) {
					// Fallback to text if JSON parse fails
					raw = await resp.text();
				}
			} else {
				raw = await resp.text();
			}
			const trimmed = (raw || '').trim();
			const match = trimmed.match(/user_[0-9]+/);
			if (match) {
				const id = match[0];
				setId(id);
				return id;
			}
		}
	} catch (e) {
		// ignore network errors and fall back
	}
	return null;
}

(function init() {
    // Use cached ID synchronously if present
    const cached = getFromStorage();
    if (cached) {
        setId(cached);
        return;
    }
    // Otherwise request one from the server, and store immediately when received
    fetchServerId();
})();

// Expose for GDScript via JavaScriptBridge.eval('window.getTheGatesUserId()')
window.getTheGatesUserId = function () { return currentId || getFromStorage() || ''; };

})();
		</script>
	</head>
	<body>
		<!-- Welcome modal removed; we show only the loading bar. -->
		<div id="tabs-buttons">
			<button id="btn-tab-loader" class="btn tab-btn" onclick="showTab('loader')">Loader</button>
			<button id="btn-tab-editor" class="btn tab-btn" disabled="disabled" onclick="showTab('editor')">Editor</button>
			<button id="btn-close-editor" class="btn close-btn" disabled="disabled" onclick="closeEditor()">×</button>
			<button id="btn-tab-game" class="btn tab-btn" disabled="disabled" onclick="showTab('game')">Game</button>
			<button id="btn-close-game" class="btn close-btn" disabled="disabled" onclick="closeGame()">×</button>
			<button id="btn-tab-update" class="btn tab-btn" style="display: none;">Update</button>
		</div>
		<div id="tabs">
			<div id="tab-loader" style="display: none;"></div>
			<div id="tab-editor" style="display: none;">
				<canvas id="editor-canvas" tabindex="1">
					HTML5 canvas appears to be unsupported in the current browser.<br >
					Please try updating or use a different browser.
				</canvas>
			</div>
			<div id="tab-game" style="display: none;">
				<canvas id="game-canvas" tabindex="2">
					HTML5 canvas appears to be unsupported in the current browser.<br >
					Please try updating or use a different browser.
				</canvas>
			</div>
			<div id="tab-status">
				<div id="status">
					<div id="status-progress" style="display: none;" oncontextmenu="event.preventDefault();">
						<div id="status-progress-label"></div>
						<div id="status-progress-bar">
							<div id="status-progress-inner"></div>
						</div>
					</div>
					<div id="status-log" style="display: none;" oncontextmenu="event.preventDefault();">
						<div id="status-log-entry"></div>
					</div>
				</div>
			</div>
		</div>
		<script>
window.addEventListener('load', () => {
	function notifyUpdate(sw) {
		const btn = document.getElementById('btn-tab-update');
		btn.onclick = function () {
			if (!window.confirm('Are you sure you want to update?\nClicking "OK" will reload all active instances!')) {
				return;
			}
			sw.postMessage('update');
			btn.innerHTML = 'Updating...';
			btn.disabled = true;
		};
		btn.style.display = '';
	}
	// Keep service worker registration minimal; no update UI.
	if ('serviceWorker' in navigator) {
		try { navigator.serviceWorker.register('service.worker.js'); } catch (e) { console.error('SW register error:', e); }
	}

	const missing = Engine.getMissingFeatures({
		threads: true,
	});
	// Only log missing feature errors; do not show modal UI
	if (missing.length) {
		console.error('Missing required features:', missing);
	}

	// Auto-start: preload template project and launch editor without user input.
	// Hide the welcome modal for a seamless start when features are available.
	// Fetch template project zip and start the editor behind the loading screen.
	fetch('template.zip').then(function (resp) {
		if (!resp.ok) { throw new Error('Failed to fetch template.zip'); }
		return resp.arrayBuffer();
	}).then(function (zipBuf) {
		startEditor(zipBuf);
	}).catch(function (e) {
		console.error('Failed to auto-start with template project:', e);
	});
});

function closeWelcomeModal(dontShowAgain) { // eslint-disable-line no-unused-vars
	document.getElementById('welcome-modal').style.display = 'none';
	if (dontShowAgain) {
		localStorage.setItem('welcomeModalDismissed', 'true');
	}
}
		</script>
		<script src="godot.editor.js"></script>
		<script>
let editor = null;
let game = null;
let setStatusMode;
let video_driver = '';
const TEMPLATE_DEST_ROOT = '/home/web_user/autoload';
const TEMPLATE_PROJECT_ROOT_KEY = 'godotTemplateProjectRoot';

function clearPersistence() { // eslint-disable-line no-unused-vars
	function deleteDB(path) {
		return new Promise(function (resolve, reject) {
			const req = indexedDB.deleteDatabase(path);
			req.onsuccess = function () {
				resolve();
			};
			req.onerror = function (err) {
				reject(err);
			};
			req.onblocked = function (err) {
				reject(err);
			};
		});
	}
	if (!window.confirm('Are you sure you want to delete all the locally stored files?\nClicking "OK" will permanently remove your projects and editor settings!')) {
		return;
	}
	Promise.all([
		deleteDB('/home/web_user'),
	]).then(function (results) {
		alert('Done.');
	}).catch(function (err) {
		alert('Error deleting local files. Please retry after reloading the page.');
	});
}

function selectVideoMode() {
	const select = document.getElementById('videoMode');
	if (select && select.selectedOptions && select.selectedOptions.length) {
		video_driver = select.selectedOptions[0].value;
	} else {
		video_driver = '';
	}
}

const tabs = [
	document.getElementById('tab-loader'),
	document.getElementById('tab-editor'),
	document.getElementById('tab-game'),
	document.getElementById('tab-status'),
];
function showTab(name) {
	tabs.forEach(function (elem) {
		if (elem.id === `tab-${name}`) {
			elem.style.display = 'block';
			if (name === 'editor' || name === 'game') {
				const canvas = document.getElementById(`${name}-canvas`);
				canvas.focus();
			}
		} else {
			elem.style.display = 'none';
		}
	});
}

function setButtonEnabled(id, enabled) {
	if (enabled) {
		document.getElementById(id).disabled = '';
	} else {
		document.getElementById(id).disabled = 'disabled';
	}
}

function setLoaderEnabled(enabled) {
	setButtonEnabled('btn-tab-loader', enabled);
	setButtonEnabled('btn-tab-editor', !enabled);
	setButtonEnabled('btn-close-editor', !enabled);
}

function setGameTabEnabled(enabled) {
	setButtonEnabled('btn-tab-game', enabled);
	setButtonEnabled('btn-close-game', enabled);
}

function closeGame() {
	if (game) {
		game.requestQuit();
	}
}

function closeEditor() { // eslint-disable-line no-unused-vars
	closeGame();
	if (editor) {
		editor.requestQuit();
	}
}

function startEditor(zip) {
	const INDETERMINATE_STATUS_STEP_MS = 100;
	const persistentPaths = ['/home/web_user'];
	const CUSTOM_THEME_SOURCE = 'editor_theme_high_ppi.tres';
	const CUSTOM_THEME_FS_PATH = '/home/web_user/.config/godot/themes/editor_theme_high_ppi.tres';
	const EDITOR_SETTINGS_FS_PATH = '/home/web_user/.config/godot/editor_settings-4.5.tres';
	const SETTINGS_SOURCE = 'editor_settings.tres';
	const textEncoder = new TextEncoder();

	function installCustomThemeTemplate() {
		const themePromise = fetch(CUSTOM_THEME_SOURCE).then(function (resp) {
			if (!resp.ok) {
				throw new Error('Failed to fetch custom editor theme template');
			}
			return resp.arrayBuffer();
		}).then(function (buffer) {
			editor.copyToFS(CUSTOM_THEME_FS_PATH, new Uint8Array(buffer));
		});
		const settingsPromise = fetch(SETTINGS_SOURCE).then(function (resp) {
			if (!resp.ok) {
				throw new Error('Failed to fetch editor settings template');
			}
			return resp.text();
		}).then(function (text) {
			const normalized = text.replace(/\r\n/g, '\n');
			const updated = normalized.replace(/interface\/theme\/custom_theme = "[^"]*"/m, 'interface/theme/custom_theme = "' + CUSTOM_THEME_FS_PATH + '"');
			editor.copyToFS(EDITOR_SETTINGS_FS_PATH, textEncoder.encode(updated));
		});
		return Promise.all([themePromise, settingsPromise]).catch(function (err) {
			console.warn('Skipping custom editor theme setup:', err);
		});
	}

	let editorCanvas = document.getElementById('editor-canvas');
	let gameCanvas = document.getElementById('game-canvas');
	const statusProgress = document.getElementById('status-progress');
	const statusProgressInner = document.getElementById('status-progress-inner');
	const statusProgressLabel = document.getElementById('status-progress-label');
	const statusLog = document.getElementById('status-log');
	const statusLogEntry = document.getElementById('status-log-entry');
	const headerDiv = document.getElementById('tabs-buttons');

	function appendStatusLog(message) {
		if (!statusLog || !statusLogEntry) {
			return;
		}
		const timestamp = new Date().toLocaleTimeString();
		const line = document.createElement('div');
		line.textContent = `[${timestamp}] ${message}`;
		statusLogEntry.appendChild(line);
		statusLog.style.display = '';
		statusLog.scrollTop = statusLog.scrollHeight;
	}

	function clearStatusLog() {
		if (!statusLogEntry) {
			return;
		}
		while (statusLogEntry.firstChild) {
			statusLogEntry.removeChild(statusLogEntry.firstChild);
		}
		if (statusLog) {
			statusLog.style.display = 'none';
		}
	}

	function updateProgress(current, total) {
		if (total > 0) {
			statusProgressInner.classList.remove('indeterminate');
			statusProgressInner.style.width = `${(current / total) * 100}%`;
			if (statusProgressLabel) {
				statusProgressLabel.textContent = `Loading engine… ${Math.round((current / total) * 100)}%`;
			}
		} else {
			statusProgressInner.classList.add('indeterminate');
			statusProgressInner.style.width = '';
			if (statusProgressLabel) {
				statusProgressLabel.textContent = 'Preparing resources…';
			}
		}
	}

	let initializing = true;
	let statusMode = 'hidden';

	showTab('status');

	let animationCallbacks = [];
	function animate(time) {
		animationCallbacks.forEach((callback) => callback(time));
		requestAnimationFrame(animate);
	}
	requestAnimationFrame(animate);

	let lastScale = 0;
	let lastWidth = 0;
	let lastHeight = 0;
	function adjustCanvasDimensions() {
		const scale = window.devicePixelRatio || 1;
		const headerHeight = headerDiv.offsetHeight + 1;
		const width = window.innerWidth;
		const height = window.innerHeight - headerHeight;
		if (lastScale !== scale || lastWidth !== width || lastHeight !== height) {
			editorCanvas.width = width * scale;
			editorCanvas.height = height * scale;
			editorCanvas.style.width = `${width}px`;
			editorCanvas.style.height = `${height}px`;
			lastScale = scale;
			lastWidth = width;
			lastHeight = height;
		}
	}
	animationCallbacks.push(adjustCanvasDimensions);
	adjustCanvasDimensions();

	function replaceCanvas(from) {
		const out = document.createElement('canvas');
		out.id = from.id;
		out.tabIndex = from.tabIndex;
		from.parentNode.replaceChild(out, from);
		lastScale = 0;
		return out;
	}

	function resolveCachedProjectRoot() {
		const cached = window.localStorage.getItem(TEMPLATE_PROJECT_ROOT_KEY);
		if (!cached) {
			return null;
		}
		try {
			const parsed = JSON.parse(cached);
			if (parsed.destRoot !== TEMPLATE_DEST_ROOT || typeof parsed.projectRoot !== 'string') {
				return null;
			}
			return parsed;
		} catch (err) {
			console.warn('Failed to parse cached template metadata:', err);
			return null;
		}
	}

	function persistCachedProjectRoot(metadata) {
		try {
			window.localStorage.setItem(TEMPLATE_PROJECT_ROOT_KEY, JSON.stringify(metadata));
		} catch (err) {
			console.warn('Failed to persist template metadata:', err);
		}
	}

	// Minimal ZIP extractor using the central directory and DecompressionStream (deflate-raw).
	// Returns the absolute project root path inside the virtual FS after extraction.
	function extractZipToFS(buffer, destRoot) {
		const dv = new DataView(buffer);
		const u8 = new Uint8Array(buffer);
		const sigEOCD = 0x06054b50;
		const sigCDH = 0x02014b50;
		const sigLFH = 0x04034b50;
		const td = new TextDecoder('utf-8');

		function findEOCD() {
			const minEOCDSize = 22;
			const maxComment = 65535;
			const start = Math.max(0, u8.length - (minEOCDSize + maxComment));
			for (let i = u8.length - minEOCDSize; i >= start; i--) {
				if (dv.getUint32(i, true) === sigEOCD) {
					return i;
				}
			}
			throw new Error('ZIP: End of central directory not found');
		}

		function decodeName(off, len) {
			return td.decode(u8.subarray(off, off + len));
		}

		async function inflateRaw(bytes) {
			// Stored (no compression) fast path
			if (bytes == null) return new Uint8Array();
			// Use DecompressionStream for raw deflate
			const ds = new DecompressionStream('deflate-raw');
			const stream = new Blob([bytes]).stream().pipeThrough(ds);
			const ab = await new Response(stream).arrayBuffer();
			return new Uint8Array(ab);
		}

		const eocd = findEOCD();
		const cdOffset = dv.getUint32(eocd + 16, true);
		let p = cdOffset;
		/** @type {Array<Promise<{name:string,data:Uint8Array}>>} */
		const filePromises = [];
		while (p < u8.length && dv.getUint32(p, true) === sigCDH) {
			const compMethod = dv.getUint16(p + 10, true);
			const compSize = dv.getUint32(p + 20, true);
			const nameLen = dv.getUint16(p + 28, true);
			const extraLen = dv.getUint16(p + 30, true);
			const commentLen = dv.getUint16(p + 32, true);
			const relOff = dv.getUint32(p + 42, true);
			const name = decodeName(p + 46, nameLen);
			// Advance to next central directory entry
			p += 46 + nameLen + extraLen + commentLen;
			// Skip directories
			if (name.endsWith('/')) {
				continue;
			}
			// Locate local file header to find data start
			if (dv.getUint32(relOff, true) !== sigLFH) {
				throw new Error('ZIP: Local file header not found');
			}
			const lfNameLen = dv.getUint16(relOff + 26, true);
			const lfExtraLen = dv.getUint16(relOff + 28, true);
			const dataStart = relOff + 30 + lfNameLen + lfExtraLen;
			const compBytes = u8.subarray(dataStart, dataStart + compSize);
			if (compMethod === 0) {
				// Stored
				filePromises.push(Promise.resolve({ name: name, data: new Uint8Array(compBytes) }));
			} else if (compMethod === 8) {
				filePromises.push(inflateRaw(compBytes).then((data) => ({ name: name, data: data })));
			} else {
				throw new Error('ZIP: Unsupported compression method ' + compMethod);
			}
		}
		return Promise.all(filePromises).then(function (entries) {
			// Copy files into FS
			entries.forEach(function (entry) {
				editor.copyToFS(destRoot + '/' + entry.name, entry.data);
			});
			// Determine project root by locating project.godot
			let projectRoot = null;
			for (const entry of entries) {
				if (entry.name === 'project.godot' || entry.name.endsWith('/project.godot')) {
					const idx = entry.name.lastIndexOf('/');
					projectRoot = (idx === -1) ? destRoot : (destRoot + '/' + entry.name.slice(0, idx));
					break;
				}
			}
			if (!projectRoot) {
				throw new Error('ZIP: project.godot not found in template');
			}
			return projectRoot;
		});
	}

	setStatusMode = function (mode) {
		if (statusMode === mode || !initializing) {
			return;
		}
		statusProgress.style.display = 'none';
		switch (mode) {
		case 'progress':
			statusProgress.style.display = 'flex';
			break;
		case 'hidden':
			break;
		default:
			throw new Error('Invalid status mode');
		}
		statusMode = mode;
	};

	const gameConfig = {
		'persistentPaths': persistentPaths,
		'unloadAfterInit': false,
		'canvas': gameCanvas,
		'canvasResizePolicy': 1,
		'onExit': function () {
			gameCanvas = replaceCanvas(gameCanvas);
			setGameTabEnabled(false);
			showTab('editor');
			game = null;
		},
	};

	let OnEditorExit = function () {
		showTab('loader');
		setLoaderEnabled(true);
	};
	function Execute(args) {
		const is_editor = args.filter(function (v) {
			return v === '--editor' || v === '-e';
		}).length !== 0;
		const is_project_manager = args.filter(function (v) {
			return v === '--project-manager';
		}).length !== 0;
		const is_game = !is_editor && !is_project_manager;
		if (video_driver) {
			args.push('--rendering-driver', video_driver);
		}

		if (is_game) {
			if (game) {
				console.error('A game is already running. Close it first');
				return;
			}
			setGameTabEnabled(true);
			game = new Engine(gameConfig);
			showTab('game');
			game.init().then(function () {
				requestAnimationFrame(function () {
					game.start({ 'args': args, 'canvas': gameCanvas }).then(function () {
						gameCanvas.focus();
					});
				});
			});
		} else { // New editor instances will be run in the same canvas. We want to wait for it to exit.
			OnEditorExit = function (code) {
				setLoaderEnabled(true);
				setTimeout(function () {
					editor.init().then(function () {
						setLoaderEnabled(false);
						OnEditorExit = function () {
							showTab('loader');
							setLoaderEnabled(true);
						};
						editor.start({ 'args': args, 'persistentDrops': is_project_manager, 'canvas': editorCanvas });
					});
				}, 0);
				OnEditorExit = null;
			};
		}
	}

	const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
	// We need at least 6 free threads from the pool to start the editor.
	// At least 4 more will be reserved for the godot thread pool (3 is the bare minimum with the multithreaded variant of the servers).
	const concurrency = clamp(navigator.hardwareConcurrency ?? 1, 12, 24);
	const editorConfig = {
		'unloadAfterInit': false,
		'onProgress': function progressFunction(current, total) {
			updateProgress(current, total);
		},
		'canvas': editorCanvas,
		'canvasResizePolicy': 0,
		'onExit': function () {
			editorCanvas = replaceCanvas(editorCanvas);
			if (OnEditorExit) {
				OnEditorExit();
			}
		},
		'onExecute': Execute,
		'persistentPaths': persistentPaths,
		'emscriptenPoolSize': concurrency,
		'godotPoolSize': Math.floor(concurrency / 3), // Ensures at least 4 threads for the pool (see above).
	};
	editor = new Engine(editorConfig);

	function displayFailureNotice(err) {
		console.error(err);
		statusProgressInner.classList.remove('indeterminate');
		statusProgressInner.style.width = '100%';
		if (statusProgressLabel) {
			statusProgressLabel.textContent = (err instanceof Error) ? err.message : String(err);
		}
		appendStatusLog(`Error: ${(err instanceof Error) ? err.message : err}`);
		setStatusMode('hidden');
		initializing = false;
	}

	if (!Engine.isWebGLAvailable()) {
		displayFailureNotice('WebGL not available');
	} else {
		clearStatusLog();
		setStatusMode('progress');
		appendStatusLog('Initializing engine runtime…');
		if (statusProgressLabel) {
			statusProgressLabel.textContent = 'Loading Godot engine…';
		}
		updateProgress(0, 0);
		editor.init('godot.editor').then(function () {
			appendStatusLog('Engine runtime ready.');
			let projectRootPromise = Promise.resolve(null);
			const themeSetupPromise = installCustomThemeTemplate();
			const cachedProject = resolveCachedProjectRoot();
			if (cachedProject) {
				appendStatusLog('Template project already available, skipping extraction.');
				projectRootPromise = Promise.resolve(cachedProject.projectRoot);
			} else if (zip) {
				appendStatusLog('Extracting template project archive…');
				if (statusProgressLabel) {
					statusProgressLabel.textContent = 'Extracting template project…';
				}
				statusProgressInner.classList.add('indeterminate');
				projectRootPromise = extractZipToFS(zip, TEMPLATE_DEST_ROOT).then(function (projectRoot) {
					persistCachedProjectRoot({ destRoot: TEMPLATE_DEST_ROOT, projectRoot: projectRoot });
					return projectRoot;
				});
			}
			try {
				// Avoid user creating project in the persistent root folder.
				editor.copyToFS('/home/web_user/keep', new Uint8Array());
			} catch (e) {
				// File exists
			}
			Promise.all([projectRootPromise, themeSetupPromise]).then(function (results) {
				const projectRoot = results[0];
				selectVideoMode();
				showTab('editor');
				setLoaderEnabled(false);
				statusProgressInner.classList.add('indeterminate');
				if (projectRoot) {
					appendStatusLog(`Template unpacked to ${projectRoot}.`);
				}
				appendStatusLog('Starting Godot editor…');
				if (statusProgressLabel) {
					statusProgressLabel.textContent = projectRoot ? 'Starting editor with template…' : 'Starting project manager…';
				}
				const args = projectRoot ? ['--editor', '--path', projectRoot, '--single-window'] : ['--project-manager', '--single-window'];
				if (video_driver) {
					args.push('--rendering-driver', video_driver);
				}
				editor.start({ 'args': args, 'persistentDrops': !projectRoot }).then(function () {
					statusProgressInner.classList.remove('indeterminate');
					statusProgressInner.style.width = '100%';
					if (statusProgressLabel) {
						statusProgressLabel.textContent = 'Ready';
					}
					appendStatusLog('Editor started successfully.');
					setStatusMode('hidden');
					initializing = false;
				});
			}).catch(displayFailureNotice);
		}).catch(displayFailureNotice);
	}
}

// Manual preload UI removed; autostart is handled on load.
		</script>
	</body>
</html>
